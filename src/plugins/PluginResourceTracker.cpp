#include "PluginResourceTracker.hpp"\n#include "../debug/Log.hpp"\n#include <algorithm>\n\nCPluginResourceTracker::CPluginResourceTracker() {\n    Log::logger->log(Log::INFO, "[PluginResourceTracker] Initializing GPU resource tracker");\n}\n\nCPluginResourceTracker::~CPluginResourceTracker() {\n    Log::logger->log(Log::INFO, "[PluginResourceTracker] Total tracked resources on shutdown: {}", m_resources.size());\n    clearAll();\n}\n\nvoid CPluginResourceTracker::trackResourceAllocation(const SPluginGPUResource& resource) {\n    if (resource.handle == 0)\n        return;\n    \n    // Check if already tracked\n    if (m_handleToIndexMap.contains(resource.handle)) {\n        Log::logger->log(Log::WARN, "[PluginResourceTracker] Handle {:x} already tracked, updating...", resource.handle);\n        size_t idx = m_handleToIndexMap[resource.handle];\n        m_resources[idx] = resource;\n        return;\n    }\n    \n    size_t index = m_resources.size();\n    m_resources.push_back(resource);\n    m_handleToIndexMap[resource.handle] = index;\n    \n    Log::logger->log(Log::TRACE, "[PluginResourceTracker] Tracked {} handle {:x} for plugin {:x} ({} bytes)",\n        resource.name, resource.handle, rc<uintptr_t>(resource.pluginHandle), resource.estimatedSize);\n}\n\nvoid CPluginResourceTracker::untrackResourceAllocation(uintptr_t handle) {\n    if (!m_handleToIndexMap.contains(handle))\n        return;\n    \n    size_t idx = m_handleToIndexMap[handle];\n    \n    Log::logger->log(Log::TRACE, "[PluginResourceTracker] Untracked {} handle {:x} for plugin {:x} ({} bytes)",\n        m_resources[idx].name, handle, rc<uintptr_t>(m_resources[idx].pluginHandle), m_resources[idx].estimatedSize);\n    \n    // Swap with last and pop\n    if (idx < m_resources.size() - 1) {\n        m_resources[idx] = m_resources.back();\n        m_handleToIndexMap[m_resources[idx].handle] = idx;\n    }\n    m_resources.pop_back();\n    m_handleToIndexMap.erase(handle);\n}\n\nstd::vector<SPluginGPUResource> CPluginResourceTracker::getResourcesForPlugin(HANDLE pluginHandle) {\n    std::vector<SPluginGPUResource> result;\n    for (const auto& res : m_resources) {\n        if (res.pluginHandle == pluginHandle)\n            result.push_back(res);\n    }\n    return result;\n}\n\nsize_t CPluginResourceTracker::getVRAMUsageForPlugin(HANDLE pluginHandle) {\n    size_t total = 0;\n    for (const auto& res : m_resources) {\n        if (res.pluginHandle == pluginHandle)\n            total += res.estimatedSize;\n    }\n    return total;\n}\n\nvoid CPluginResourceTracker::forceCleanupPlugin(HANDLE pluginHandle) {\n    auto resources = getResourcesForPlugin(pluginHandle);\n    \n    Log::logger->log(Log::WARN, "[PluginResourceTracker] Force-cleaning {} resources for plugin {:x}",\n        resources.size(), rc<uintptr_t>(pluginHandle));\n    \n    for (const auto& res : resources) {\n        untrackResourceAllocation(res.handle);\n    }\n}\n\nconst std::vector<SPluginGPUResource>& CPluginResourceTracker::getAllResources() const {\n    return m_resources;\n}\n\nvoid CPluginResourceTracker::clearAll() {\n    Log::logger->log(Log::DEBUG, "[PluginResourceTracker] Clearing {} tracked resources", m_resources.size());\n    m_resources.clear();\n    m_handleToIndexMap.clear();\n}